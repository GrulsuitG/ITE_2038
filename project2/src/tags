!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Q	bpt.c	/^node * Q = NULL;$/;"	v
Version	bpt.c	4;"	d	file:
adjust_root	bpt.c	/^node * adjust_root(node * root) {$/;"	f
coalesce_nodes	bpt.c	/^node * coalesce_nodes(node * root, node * n, node * neighbor, int neighbor_index, int k_prime) {$/;"	f
cut	bpt.c	/^int cut( int length ) {$/;"	f
db_delete	db.c	/^int db_delete(int64_t key){ return 0;}$/;"	f
db_find	db.c	/^int db_find(int64_t key, char *ret_val){ return 0;}$/;"	f
db_insert	db.c	/^int db_insert(int64_t key, char* value){$/;"	f
delete	bpt.c	/^node * delete(node * root, int key) {$/;"	f
delete_entry	bpt.c	/^node * delete_entry( node * root, node * n, int key, void * pointer ) {$/;"	f
dequeue	bpt.c	/^node * dequeue( void ) {$/;"	f
destroy_tree	bpt.c	/^node * destroy_tree(node * root) {$/;"	f
destroy_tree_nodes	bpt.c	/^void destroy_tree_nodes(node * root) {$/;"	f
enqueue	bpt.c	/^void enqueue( node * new_node ) {$/;"	f
file_alloc_page	file.c	/^pagenum_t file_alloc_page(){$/;"	f
file_free_page	file.c	/^void file_free_page(pagenum_t pagenum){$/;"	f
file_read_page	file.c	/^void file_read_page(pagenum_t pagenum, page_t* dest){$/;"	f
file_write_page	file.c	/^void file_write_page(pagenum_t pagenum, const page_t* src){$/;"	f
filename	db.c	/^char* filename;$/;"	v
filename	file.c	/^char* filename;$/;"	v
find	bpt.c	/^record * find( node * root, int key, bool verbose ) {$/;"	f
find_and_print	bpt.c	/^void find_and_print(node * root, int key, bool verbose) {$/;"	f
find_and_print_range	bpt.c	/^void find_and_print_range( node * root, int key_start, int key_end,$/;"	f
find_leaf	bpt.c	/^node * find_leaf( node * root, int key, bool verbose ) {$/;"	f
find_range	bpt.c	/^int find_range( node * root, int key_start, int key_end, bool verbose,$/;"	f
free_page	file.c	/^void free_page(page_t *page){$/;"	f
get_left_index	bpt.c	/^int get_left_index(node * parent, node * left) {$/;"	f
get_neighbor_index	bpt.c	/^int get_neighbor_index( node * n ) {$/;"	f
get_random_number	main.c	/^int get_random_number(int from, int to) {$/;"	f
get_random_str	main.c	/^void get_random_str(char* data, int len) {$/;"	f
height	bpt.c	/^int height( node * root ) {$/;"	f
init_inter	file.c	/^page_t* init_inter(){$/;"	f
init_leaf	file.c	/^page_t* init_leaf(){$/;"	f
init_page	file.c	/^page_t* init_page(){$/;"	f
insert	bpt.c	/^node * insert( node * root, int key, char *value ) {$/;"	f
insert_into_leaf	bpt.c	/^node * insert_into_leaf( node * leaf, int key, record * pointer ) {$/;"	f
insert_into_leaf_after_splitting	bpt.c	/^node * insert_into_leaf_after_splitting(node * root, node * leaf, int key, record * pointer) {$/;"	f
insert_into_new_root	bpt.c	/^node * insert_into_new_root(node * left, int key, node * right) {$/;"	f
insert_into_node	bpt.c	/^node * insert_into_node(node * root, node * n, $/;"	f
insert_into_node_after_splitting	bpt.c	/^node * insert_into_node_after_splitting(node * root, node * old_node, int left_index, $/;"	f
insert_into_parent	bpt.c	/^node * insert_into_parent(node * root, node * left, int key, node * right) {$/;"	f
license_notice	bpt.c	/^void license_notice( void ) {$/;"	f
main	main.c	/^int main(){$/;"	f
make_file	file.c	/^void make_file(){$/;"	f
make_leaf	bpt.c	/^node * make_leaf( void ) {$/;"	f
make_node	bpt.c	/^node * make_node( void ) {$/;"	f
make_record	bpt.c	/^record * make_record(char *value) {$/;"	f
node_to_page	db.c	/^void node_to_page(node *n, page_t *page){$/;"	f
open_table	db.c	/^int open_table(char *pathname){ $/;"	f
order	bpt.c	/^int order = DEFAULT_ORDER;$/;"	v
path_to_root	bpt.c	/^int path_to_root( node * root, node * child ) {$/;"	f
print_leaves	bpt.c	/^void print_leaves( node * root ) {$/;"	f
print_license	bpt.c	/^void print_license( int license_part ) {$/;"	f
print_tree	bpt.c	/^void print_tree( node * root ) {$/;"	f
queue	bpt.c	/^node * queue = NULL;$/;"	v
redistribute_nodes	bpt.c	/^node * redistribute_nodes(node * root, node * n, node * neighbor, int neighbor_index, $/;"	f
remove_entry_from_node	bpt.c	/^node * remove_entry_from_node(node * n, int key, node * pointer) {$/;"	f
start_new_tree	bpt.c	/^node * start_new_tree(int key, record * pointer) {$/;"	f
usage_2	bpt.c	/^void usage_2( void ) {$/;"	f
verbose_output	bpt.c	/^bool verbose_output = false;$/;"	v
